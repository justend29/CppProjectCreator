#!/bin/bash
# great cmake resources:
#   http://www.brianlheim.com/2018/04/09/cmake-cheat-sheet.html
#   https://raymii.org/s/tutorials/Cpp_project_setup_with_cmake_and_unit_tests.html
set -e

if [ -z "$1" ]; then
	echo -e "Must supply project name\nex. cpp_proj <proj> <target>"
	exit 1
fi
if [ -z "$2" ]; then
	echo -e "Must supply target name\nex. cpp_proj <proj> <target>"
	exit 1
fi

printColourized () {
	#$1 ansi escape sequence colour
	#$2 is the text to print
	printf  "$1 ${2} \e[0m"
}

#relative to root directory
dirsToMake=("include" "include/$1" "build" "src" "lib" "bin" "test" "doc")
#ansi colours
red=$'\e[1;31m'
grn=$'\e[1;92m'
blu=$'\e[1;34m'
mag=$'\e[1;35m'
cyn=$'\e[1;36m'
ylw=$'\e[1;33m'
white=$'\e[0m'

makeDir() {
	#$1 is relative path of desired directory
	if [ -d "$(pwd)/$1" ]; then
		printColourized ${cyn}  "$(pwd)/$1"
		echo -n " exists. Overwrite? [y/N]"
		read response
		if [ "$response" = "y" ]; then
			rm -rf "$(pwd)/$1"
			mkdir "$(pwd)/$1"
			echo "overwrote directory"
		else
			echo "skipping creation of directory"
		fi
	else
		mkdir "$(pwd)/$1"
		echo "writing"
	fi
}

makeFile() {
	#$1 is relative path to desired file
	#$2 is contents of desired file
	if [ -f "$(pwd)/$1" ]; then
		printColourized ${grn}  "$(pwd)/$1"
		echo -n " exists. Overwrite? [y/N]"
		read response
		if [ "$response" = "y" ]; then
			echo -e "$2" > $1
			echo "overwrote file"
		else
			echo "skipping creation of file"
		fi
	else 
		echo -e "$2" > $1
	fi
}

#project directory structure
for directory in ${dirsToMake[@]}; do
	makeDir $directory
done

#git ignore
gitIgnoreBody=$(cat <<EOF
build/
bin/
compile_commands.json
*.zip
*.tar
*.o
*.swp
EOF
)
makeFile ".gitignore" "$gitIgnoreBody"
chmod ug+w "$(pwd)/.gitignore"

#readme
makeFile "README.md" "# $1"

#main file
mainBody=$(cat <<EOF
#include "$1-config.hpp"
int main() {
}
EOF
)
makeFile "src/main.cpp" "$mainBody"

#project files
if [ "$(ls -1q src/*.cpp | wc -l)" -eq "1" ]; then
  makeFile "src/$1.cpp" "// rename me to what your project needs"
fi

#config header
configBody=$(cat <<EOF
#cmakedefine $1_VERSION_MAJOR @$1_VERSION_MAJOR@
#cmakedefine $1_VERSION_MINOR @$1_VERSION_MINOR@
#cmakedefine $1_VERSION_PATCH @$1_VERSION_PATCH@
EOF
)
makeFile "$1-config.hpp.in" "$configBody"
chmod ug+w "$(pwd)/$1-config.hpp.in"

#tests
testFileBody=$(cat <<EOF
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
TEST_CASE() {
}
EOF
)
testFile="main-test.cpp"
makeFile "test/$testFile" "$testFileBody"

#cmake
cmakeVersion=$(cmake --version | grep version | cut -f 3 -d " ")
cmakeBody=$(cat <<EOF
if( NOT WIN32 )
  set( BLU "$blu" CACHE STRING "AnsiBlue" )
  set( RED "$red" CACHE STRING "AnsiRed" )
  set( MAG "$mag" CACHE STRING "AnsiMagenta" )
  set( CYN "$cyn" CACHE STRING "AnsiCyan" )
  set( YLW "$ylw" CACHE STRING "AnsiYellow" )
  set( WHT "$white" CACHE STRING "AnsiWhite" )
  function( colourized MESSAGE COL )
    message( "\${COL}\${MESSAGE}\${WHT}" )
  endfunction()
endif()

cmake_minimum_required( VERSION $cmakeVersion )
project( $1 VERSION 0 )
colourized( "CMAKE_PROJECT_NAME: \${CMAKE_PROJECT_NAME}" \${MAG})
colourized( "PROJECT_SOURCE_DIR: \${PROJECT_SOURCE_DIR}" \${MAG})
colourized( "PROJECT_BINARY_DIR: \${PROJECT_BINARY_DIR}" \${MAG})

# target
# glob collection of src files not reliable to regenerate cmake. Manually specify SRCS if fails
file( GLOB SRCS LIST_DIRECTORIES false CONFIGURE_DEPENDS \${PROJECT_SOURCE_DIR}/src/*.cpp )
list( REMOVE_ITEM SRCS \${PROJECT_SOURCE_DIR}/src/main.cpp )
add_library( $2 STATIC \${SRCS} )
add_executable( $2_driver \${PROJECT_SOURCE_DIR}/src/main.cpp )
target_link_libraries( $2_driver $2 )

configure_file( \${CMAKE_PROJECT_NAME}-config.hpp.in \${PROJECT_SOURCE_DIR}/src/\${CMAKE_PROJECT_NAME}-config.hpp )

# flags
set_target_properties( $2
  PROPERTIES
  CXX_STANDARD 17
  CXX_STANDARD_REQUIRED True
  ARCHIVE_OUTPUT_DIRECTORY "\${PROJECT_SOURCE_DIR}/lib"
  LIBRARY_OUTPUT_DIRECTORY "\${PROJECT_SOURCE_DIR}/lib"
  RUNTIME_OUTPUT_DIRECTORY "\${PROJECT_SOURCE_DIR}/bin" )

set( OPTS "" )
if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
  set( OPTS "-Wall -Wextra -Werror -Wctor-dtor-privacy -Wno-init-list-lifetime -Wnoexcept -Weffc++ -Wstrict-null-sentinel -Wold-style-cast -Woverloaded-virtual -Wsign-promo" )
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
endif()

colourized( "Compile Options: \${OPTS}" \${YLW} )
# PUBLIC will propogate opts to all linked targets
separate_arguments(OPTS)
target_compile_options( $2 PUBLIC \${OPTS} )

target_include_directories( $2 PUBLIC \${PROJECT_BINARY_DIR} \${PROJECT_SOURCE_DIR}/include \${PROJECT_SOURCE_DIR}/src )

# any 3rd party libs? Add here

#using Catch2 testing header
enable_testing()
add_executable( \${CMAKE_PROJECT_NAME}_test \${PROJECT_SOURCE_DIR}/test/$testFile )
add_test( NAME \${CMAKE_PROJECT_NAME}_test COMMAND \${CMAKE_PROJECT_NAME}_test )

set( CMAKE_EXPORT_COMPILE_COMMANDS ON )
EOF
)


makeFile "CMakeLists.txt" "$cmakeBody"
chmod ug+w "$(pwd)/CMakeLists.txt"

#call cmake
cmake -B "$(pwd)/build/"
if [ ! -f "$(pwd)/compile_commands.json" ]; then
	ln -s "$(pwd)/build/compile_commands.json" "$(pwd)/compile_commands.json"
fi

#call git
if [ -d ".git" ]; then
	printColourized ${mag}  ".git"
	echo -n " exists. Call git init? [y/N]"
	read response
	if [ "$response" = "y" ]; then
		git init
	fi
else 
	git init
fi
